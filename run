#! /usr/bin/env python
# PYTHON_ARGCOMPLETE_OK

# Imports
import sys, os, shutil, argparse, argcomplete, tomllib, subprocess

# Helper functions
def on_config_error(text: str):
  print(f'Configuration error:\n{text}')
  sys.exit(1)

# Parsing config
config_file = './run-config.toml'
try:
  config = tomllib.loads(open(config_file, 'r').read())
except tomllib.TOMLDecodeError as e:
  on_config_error(e)
  sys.exit(1)
except FileNotFoundError:
  on_config_error('Configuration file not found.')
  sys.exit(1)

# Checking config sections
for section in ['config', 'builds']:
  if section not in config:
    on_config_error(f"Missing required section '{item}'.")
    sys.exit(1)

# Shorthand vars
builds = config.get('builds')
config = config.get('config')

# Checking config items
for item in ['build-dir']:
  value = config.get(item)
  if not value:
    on_config_error(f"Missing required item '{item}' in [config] section.")
    sys.exit(1)

# Parsing input
parser = argparse.ArgumentParser(
  description = 'Application runner',
)
build_choices = [build for build in builds]
parser.add_argument(
  'build', choices=build_choices,
  default=build_choices[0],
  const=build_choices[0],
  nargs='?',
)
argcomplete.autocomplete(parser)
args = parser.parse_args()
selected_build = builds.get(args.build)

# Cleaning build-dir
build_dir = config.get('build-dir')
if os.path.isdir(build_dir):
  shutil.rmtree(build_dir)
os.mkdir(build_dir)

def configure_command(command: str) -> str:
  for key in config:
    if f'${key}' in command:
      command = command.replace(f'${key}', config.get(key))
  return os.path.expanduser(command)

def clear_line():
  sys.stdout.write("\x1b[2K")

# Running build
print(f'Running {args.build} build:')
for msg in selected_build:
  clear_line()
  print(msg.title() + '...')
  command = selected_build.get(msg)
  command_type = type(command)
  if command_type is str:
    command = configure_command(command)
    os.system(command)
  elif command_type is list:
    for subcommand in command:
      subcommand = configure_command(subcommand)
      clear_line()
      print(f" Running '{subcommand}'...", end='\r')
      process = subprocess.run(
        subcommand.split(' '), stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
      )
      status = process.returncode
      if status != 0:
        clear_line()
        print(f"Encountered error running '{subcommand}':")
        print(process.stdout.decode('utf-8'))
        sys.exit(1)
  else:
    raise NotImplementedError()
